// Funcbeat.cpp : This file contains the 'main' function. Program execution begins and ends there.
// Funcbeat code : potasmic - go to sleep

#define _USE_MATH_DEFINES
#define BB_TIME 60000                   //60000 milliseconds = 60 seconds = 1 minute

#include <windows.h>
#include <mmsystem.h>
#include <cmath>
#include <vector>
#include <algorithm>
#include <iostream>
#include <Mmreg.h>
#pragma comment(lib, "winmm.lib")       //Since I struggled a lot to use this library on MinGW, I recommend using Visual Studio to run this code.



DWORD WINAPI Funcbeat() {
    std::cout << "Playing Funcbeat\n";
    DWORD SampleRate = 8000;            //Using lower frequency to make it last longer. You can change it to higher frequency foy better sound quality.
    HWAVEOUT hwo = 0;
    WAVEFORMATEX wfx = {
        WAVE_FORMAT_PCM,
        1,
        SampleRate,
        SampleRate,
        1,
        8,
        0
    };
	

    waveOutOpen(&hwo, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
    char buffer[32768 * 14];
    float _t = 0;
    float s = 0;
    int16_t pcmtmp = 0;
    for (DWORD t= 0; t < sizeof(buffer); t++) {
        //Insert your Funcbeat code here.
        float s = 0;
        float feedback = 0.4;
        std::vector<float> p = { 0.737, 0.415, 0.322, 0.17 };
        float tf = static_cast<float>(t) / SampleRate;
        for (float i = 0; i < M_PI; i += M_PI / 7) {
            _t = tf < M_PI ? tf : tf - i;
            s += 0.3 * sin(2 * M_PI * _t * (440 + 440 * ((i / 0.75))) * p[static_cast<int>(round(_t / M_PI / 2)) % p.size() ])* exp(0.01 - fmod(_t, M_PI))* (feedback - (i / 4) * feedback);
        }

        //Convert float to Signed 8bit PCM
        int8_t pcmtmp = static_cast<int8_t>((s + 1.0f) * 127.5f);
        int pcmmax = max(-128, pcmtmp);     //clamp
        pcmtmp = min(127, pcmmax);          //clamp
        //Cast into char
        buffer[t] = static_cast<unsigned char>(pcmtmp);
        //std::cout << pcmtmp << std::endl;
    }

    WAVEHDR hdr = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0};
    waveOutPrepareHeader(hwo, &hdr, sizeof(WAVEHDR));
    waveOutWrite(hwo, &hdr, sizeof(WAVEHDR));
    waveOutUnprepareHeader(hwo, &hdr, sizeof(WAVEHDR));

	Sleep(BB_TIME);         //Wait for the sound to finish playing
    waveOutReset(hwo);      //Reset device
    waveOutClose(hwo);      //Close device
    return 0;
}


/********************************Here's a normal Bytebeat for the reference********************************/
DWORD WINAPI Bytebeat() {
    std::cout << "Playing Bytebeat\n";
    HWAVEOUT hwo = 0;
    WAVEFORMATEX wfx = {
        WAVE_FORMAT_PCM,
        1,
        8000,   //Sample rate
        8000,
        1,
        8,
        0
    };
    waveOutOpen(&hwo, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
    char buffer[32768 * 3];
    for (int t = 0; t < sizeof(buffer); t++)
        buffer[t] = static_cast<char>(129E3 > t ? (35E3 > t ? 8 : 84E3 > t ? 9 : 8) * t | (t >> 2) + (67500 > t ? 13 : 98E3 > t ? 12 : 13) * t | t >> 3 | t >> 5 : 0);     //Insert your own bytebeat code here
    WAVEHDR hdr = { buffer,
        sizeof(buffer),
        0,
        0,
        WHDR_BEGINLOOP | WHDR_ENDLOOP,
        5,      //Loop 5 times
        0,
        0 };
    waveOutPrepareHeader(hwo, &hdr, sizeof(WAVEHDR));
    waveOutWrite(hwo, &hdr, sizeof(WAVEHDR));
    waveOutUnprepareHeader(hwo, &hdr, sizeof(WAVEHDR));
    Sleep(BB_TIME);
    waveOutReset(hwo);
    waveOutClose(hwo);
    return 0;
}


/************************************************************************************************
    Here is an example code generated by Google AI Overview.
    This code is modified to play Funcbeat.
************************************************************************************************/

#define SAMPLE_RATE 16000
#define BUFFER_SIZE 65536
float generate_sample(float t) {
    // Example floatbeat formula (can be modified)
    float feedback = 0.4;
    float s = 0;
    float _t;
    std::vector<float> p = { 0.737, 0.415, 0.322, 0.17 };
    for (float i = 0; i < M_PI; i += M_PI / 7) {
        _t = t < M_PI ? t : t - i;
        s += 0.3 * sin(2 * M_PI * _t * (440 + 440 * ((i / 0.75))) * p[static_cast<int>(round(_t / M_PI / 2)) % p.size()]) * exp(0.01 - fmod(_t, M_PI)) * (feedback - (i / 4) * feedback);
    }
    return s;
}

DWORD WINAPI GoogleFloatbeat() {
    std::cout << "Playing GoogleFloatbeat\nThis function does not return, so please close this window manualy,";
    WAVEFORMATEX wfx;
    wfx.wFormatTag = WAVE_FORMAT_IEEE_FLOAT;
    wfx.nChannels = 1;
    wfx.nSamplesPerSec = SAMPLE_RATE;
    wfx.nAvgBytesPerSec = SAMPLE_RATE * 4;
    wfx.nBlockAlign = 4;
    wfx.wBitsPerSample = 32;
    wfx.cbSize = 0;

    HWAVEOUT hwo;
    waveOutOpen(&hwo, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);

    float buffer[BUFFER_SIZE];
    WAVEHDR header;
    header.lpData = (LPSTR)buffer;
    header.dwBufferLength = BUFFER_SIZE * 4;
    header.dwFlags = 0;
    header.dwLoops = 0;

    waveOutPrepareHeader(hwo, &header, sizeof(WAVEHDR));

    float t = 0;
    while (true) {
        for (int i = 0; i < BUFFER_SIZE; i++) {
            buffer[i] = generate_sample(t);
            t += 1.0 / SAMPLE_RATE;
            //Sleep(1);
        }
        waveOutWrite(hwo, &header, sizeof(WAVEHDR));
        //waveOutReset(hwo);
        Sleep(4096);
    }
    //waveOutWrite(hwo, &header, sizeof(WAVEHDR));
    //Sleep(10000);
    waveOutClose(hwo);
    return 0;
}



/********************************Main********************************/

int main()
{
    std::cout << "Funcbeat for C++ by 0x0_nyan\n";
    Funcbeat();
    Bytebeat();
    //GoogleFloatbeat();
	return 0;
}

